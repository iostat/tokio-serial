//! Bindings for serial port I/O and futures
//!
//! This crate provides bindings between `mio_serial`, a mio crate for
//! serial port I/O, and `futures`.  The API is very similar to the
//! bindings in `mio_serial`
//!
#![deny(missing_docs)]
#![warn(rust_2018_idioms)]

// Re-export serialport types and traits from mio_serial
//
// todo: now that `mio` is completely abstracted away as an implementation detail in tokio-1,
// todo: we really don't need to depend on mio-serial... in fact, all have now is just two layers
// todo: of SerialPort impls of tokio_serial::Serial -> mio_serial::Serial -> serialport::TTYPort
// todo: while the only advantage we get from this is mio_serial::Serial's construct sets
// todo: tcattr.control[VMIN] and the O_NONBLOCK fd flag, and we dont have to do two unsafe libc
// todo: to read/write the fd...
pub use mio_serial::{
    ClearBuffer, DataBits, Error, ErrorKind, FlowControl, Parity, SerialPort, SerialPortSettings,
    StopBits,
};

/// A type for results generated by interacting with serial ports.
pub type Result<T> = mio_serial::Result<T>;

use tokio::io::{unix::AsyncFd, unix::TryIoError, AsyncRead, AsyncWrite, ReadBuf};

use std::io::{self, Read, Write};
use std::path::Path;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::Duration;

/// Serial port I/O struct.
pub struct Serial {
    inner: mio_serial::Serial,
    io: AsyncFd<RawFd>,
}

impl Serial {
    /// Open serial port from a provided path, using the default reactor.
    pub fn from_path<P>(path: P, settings: &mio_serial::SerialPortSettings) -> io::Result<Serial>
    where
        P: AsRef<Path>,
    {
        let inner = mio_serial::Serial::from_path(path.as_ref(), settings)?;
        let io = AsyncFd::new(inner.as_raw_fd())?;

        Ok(Serial { inner, io })
    }

    /// Create a pair of pseudo serial terminals using the default reactor
    ///
    /// ## Returns
    /// Two connected, unnamed `Serial` objects.
    ///
    /// ## Errors
    /// Attempting any IO or parameter settings on the slave tty after the master
    /// tty is closed will return errors.
    ///
    #[cfg(unix)]
    pub fn pair() -> Result<(Self, Self)> {
        let (master, slave) = mio_serial::Serial::pair()?;

        let master_fd = master.as_raw_fd();
        let master = Serial {
            inner: master,
            io: AsyncFd::new(master_fd)?,
        };
        let slave_fd = slave.as_raw_fd();
        let slave = Serial {
            inner: slave,
            io: AsyncFd::new(slave_fd)?,
        };
        Ok((master, slave))
    }

    /// Sets the exclusivity of the port
    ///
    /// If a port is exclusive, then trying to open the same device path again
    /// will fail.
    ///
    /// See the man pages for the tiocexcl and tiocnxcl ioctl's for more details.
    ///
    /// ## Errors
    ///
    /// * `Io` for any error while setting exclusivity for the port.
    #[cfg(unix)]
    pub fn set_exclusive(&mut self, exclusive: bool) -> Result<()> {
        self.inner.set_exclusive(exclusive)
    }

    /// Returns the exclusivity of the port
    ///
    /// If a port is exclusive, then trying to open the same device path again
    /// will fail.
    #[cfg(unix)]
    pub fn exclusive(&self) -> bool {
        self.inner.exclusive()
    }
}

impl SerialPort for Serial {
    fn settings(&self) -> SerialPortSettings {
        self.inner.settings()
    }

    fn name(&self) -> Option<String> {
        self.inner.name()
    }

    fn baud_rate(&self) -> Result<u32> {
        self.inner.baud_rate()
    }

    fn data_bits(&self) -> Result<DataBits> {
        self.inner.data_bits()
    }

    fn flow_control(&self) -> Result<FlowControl> {
        self.inner.flow_control()
    }

    fn parity(&self) -> Result<Parity> {
        self.inner.parity()
    }

    fn stop_bits(&self) -> Result<StopBits> {
        self.inner.stop_bits()
    }

    fn timeout(&self) -> Duration {
        Duration::from_secs(0)
    }

    fn set_all(&mut self, settings: &SerialPortSettings) -> Result<()> {
        self.inner.set_all(settings)
    }

    fn set_baud_rate(&mut self, baud_rate: u32) -> Result<()> {
        self.inner.set_baud_rate(baud_rate)
    }

    fn set_data_bits(&mut self, data_bits: DataBits) -> Result<()> {
        self.inner.set_data_bits(data_bits)
    }

    fn set_flow_control(&mut self, flow_control: FlowControl) -> Result<()> {
        self.inner.set_flow_control(flow_control)
    }

    fn set_parity(&mut self, parity: Parity) -> Result<()> {
        self.inner.set_parity(parity)
    }

    fn set_stop_bits(&mut self, stop_bits: StopBits) -> Result<()> {
        self.inner.set_stop_bits(stop_bits)
    }

    fn set_timeout(&mut self, _: Duration) -> Result<()> {
        Ok(())
    }

    fn write_request_to_send(&mut self, level: bool) -> Result<()> {
        self.inner.write_request_to_send(level)
    }

    fn write_data_terminal_ready(&mut self, level: bool) -> Result<()> {
        self.inner.write_data_terminal_ready(level)
    }

    fn read_clear_to_send(&mut self) -> Result<bool> {
        self.inner.read_clear_to_send()
    }

    fn read_data_set_ready(&mut self) -> Result<bool> {
        self.inner.read_data_set_ready()
    }

    fn read_ring_indicator(&mut self) -> Result<bool> {
        self.inner.read_ring_indicator()
    }

    fn read_carrier_detect(&mut self) -> Result<bool> {
        self.inner.read_carrier_detect()
    }

    fn bytes_to_read(&self) -> Result<u32> {
        self.inner.bytes_to_read()
    }

    fn bytes_to_write(&self) -> Result<u32> {
        self.inner.bytes_to_write()
    }

    fn clear(&self, buffer_to_clear: ClearBuffer) -> Result<()> {
        self.inner.clear(buffer_to_clear)
    }

    fn try_clone(&self) -> Result<Box<dyn SerialPort>> {
        self.inner.try_clone()
    }
}

impl Read for Serial {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.inner.read(buf)
    }
}

impl Write for Serial {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.inner.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

#[cfg(unix)]
use std::os::unix::io::{AsRawFd, RawFd};
#[cfg(unix)]
impl AsRawFd for Serial {
    fn as_raw_fd(&self) -> RawFd {
        self.io.get_ref().as_raw_fd()
    }
}

impl AsyncRead for Serial {
    fn poll_read(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut ReadBuf<'_>,
    ) -> Poll<io::Result<()>> {
        let this = self.get_mut();
        let inner = &mut this.inner;
        let pinned = Pin::new(&mut this.io);
        let mut guard = match pinned.poll_read_ready(cx) {
            Poll::Ready(Ok(x)) => x,
            Poll::Ready(Err(e)) => return Poll::Ready(Err(e)),
            Poll::Pending => return Poll::Pending,
        };

        // not entirely sure why I have to do this -- it seems like occasionally the
        // ready flag gets cleared even though there's still data to be read?
        // (i.e., AsyncFdReadyGuard::try_io ostensibly only clears the ready flag if
        // it got an io::Err(EWOULDBLOCK), which shouldn't be possible if there's still data to
        // be read. unless there's some really strange/erroneous semantics with read on USB serial
        // devices :P)

        // perhaps some funky race condition in tokio runtime introduced in 0.3/1.0??
        let res = guard.try_io(|_afd| {
            let read = inner.read(buf.initialize_unfilled())?;
            buf.advance(read);
            let post_available = inner.bytes_to_read()?;
            Ok(post_available)
        });

        match res {
            Ok(Ok(bytes_still_available)) => {
                if bytes_still_available > 0 {
                    guard.retain_ready();
                }
                Poll::Ready(Ok(()))
            }
            Ok(Err(e)) => Poll::Ready(Err(e)),
            Err(TryIoError { .. }) => Poll::Pending,
        }
    }
}

impl AsyncWrite for Serial {
    fn poll_write(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &[u8],
    ) -> Poll<io::Result<usize>> {
        let this = self.get_mut();
        let inner = &mut this.inner;
        let pinned = Pin::new(&mut this.io);
        let mut guard = match pinned.poll_write_ready(cx) {
            Poll::Ready(Ok(x)) => x,
            Poll::Ready(Err(e)) => return Poll::Ready(Err(e)),
            Poll::Pending => return Poll::Pending,
        };
        match guard.try_io(|_afd| inner.write(buf)) {
            Ok(x) => Poll::Ready(x),
            Err(TryIoError { .. }) => Poll::Pending,
        }
    }

    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {
        let this = self.get_mut();
        let inner = &mut this.inner;
        let pinned = Pin::new(&mut this.io);
        let mut guard = match pinned.poll_write_ready(cx) {
            Poll::Ready(Ok(x)) => x,
            Poll::Ready(Err(e)) => return Poll::Ready(Err(e)),
            Poll::Pending => return Poll::Pending,
        };
        let res = guard.try_io(|_afd| inner.flush());
        match res {
            Ok(x) => Poll::Ready(x),
            Err(TryIoError { .. }) => Poll::Pending,
        }
    }

    fn poll_shutdown(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<io::Result<()>> {
        Poll::Ready(Ok(()))
    }
}
