//! Bindings for serial port I/O and futures
//!
//! This crate provides bindings between `mio_serial`, a mio crate for
//! serial port I/O, and `futures`.  The API is very similar to the
//! bindings in `mio_serial`
//!
#![deny(missing_docs)]
#![warn(rust_2018_idioms)]

// Re-export serialport types and traits from mio_serial
//
// todo: now that `mio` is completely abstracted away as an implementation detail in tokio-1,
// todo: we really don't need to depend on mio-serial... in fact, all have now is just two layers
// todo: of SerialPort impls of tokio_serial::Serial -> mio_serial::Serial -> serialport::TTYPort
// todo: while the only advantage we get from this is mio_serial::Serial's construct sets
// todo: tcattr.control[VMIN] and the O_NONBLOCK fd flag, and we dont have to do two unsafe libc
// todo: to read/write the fd...
pub use mio_serial::{
    ClearBuffer, DataBits, Error, ErrorKind, FlowControl, Parity, SerialPort, SerialPortSettings,
    StopBits,
};

/// A type for results generated by interacting with serial ports.
pub type Result<T> = mio_serial::Result<T>;

use tokio::io::{unix::AsyncFd, unix::TryIoError, AsyncRead, AsyncWrite, ReadBuf};

use std::io::{self, Read, Write};
use std::path::Path;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::Duration;

/// Serial port I/O struct.
pub struct Serial {
    inner: mio_serial::Serial,
    io: AsyncFd<RawFd>,
}

impl Serial {
    /// Open serial port from a provided path, using the default reactor.
    pub fn from_path<P>(path: P, settings: &mio_serial::SerialPortSettings) -> io::Result<Serial>
    where
        P: AsRef<Path>,
    {
        let inner = mio_serial::Serial::from_path(path.as_ref(), settings)?;
        let io = AsyncFd::new(inner.as_raw_fd())?;

        Ok(Serial { inner, io })
    }

    /// Create a pair of pseudo serial terminals using the default reactor
    ///
    /// ## Returns
    /// Two connected, unnamed `Serial` objects.
    ///
    /// ## Errors
    /// Attempting any IO or parameter settings on the slave tty after the master
    /// tty is closed will return errors.
    ///
    #[cfg(unix)]
    pub fn pair() -> Result<(Self, Self)> {
        let (master, slave) = mio_serial::Serial::pair()?;

        let master_fd = master.as_raw_fd();
        let master = Serial {
            inner: master,
            io: AsyncFd::new(master_fd)?,
        };
        let slave_fd = slave.as_raw_fd();
        let slave = Serial {
            inner: slave,
            io: AsyncFd::new(slave_fd)?,
        };
        Ok((master, slave))
    }

    /// Sets the exclusivity of the port
    ///
    /// If a port is exclusive, then trying to open the same device path again
    /// will fail.
    ///
    /// See the man pages for the tiocexcl and tiocnxcl ioctl's for more details.
    ///
    /// ## Errors
    ///
    /// * `Io` for any error while setting exclusivity for the port.
    #[cfg(unix)]
    pub fn set_exclusive(&mut self, exclusive: bool) -> Result<()> {
        self.inner.set_exclusive(exclusive)
    }

    /// Returns the exclusivity of the port
    ///
    /// If a port is exclusive, then trying to open the same device path again
    /// will fail.
    #[cfg(unix)]
    pub fn exclusive(&self) -> bool {
        self.inner.exclusive()
    }
}

impl SerialPort for Serial {
    fn settings(&self) -> SerialPortSettings {
        self.inner.settings()
    }

    fn name(&self) -> Option<String> {
        self.inner.name()
    }

    fn baud_rate(&self) -> Result<u32> {
        self.inner.baud_rate()
    }

    fn data_bits(&self) -> Result<DataBits> {
        self.inner.data_bits()
    }

    fn flow_control(&self) -> Result<FlowControl> {
        self.inner.flow_control()
    }

    fn parity(&self) -> Result<Parity> {
        self.inner.parity()
    }

    fn stop_bits(&self) -> Result<StopBits> {
        self.inner.stop_bits()
    }

    fn timeout(&self) -> Duration {
        Duration::from_secs(0)
    }

    fn set_all(&mut self, settings: &SerialPortSettings) -> Result<()> {
        self.inner.set_all(settings)
    }

    fn set_baud_rate(&mut self, baud_rate: u32) -> Result<()> {
        self.inner.set_baud_rate(baud_rate)
    }

    fn set_data_bits(&mut self, data_bits: DataBits) -> Result<()> {
        self.inner.set_data_bits(data_bits)
    }

    fn set_flow_control(&mut self, flow_control: FlowControl) -> Result<()> {
        self.inner.set_flow_control(flow_control)
    }

    fn set_parity(&mut self, parity: Parity) -> Result<()> {
        self.inner.set_parity(parity)
    }

    fn set_stop_bits(&mut self, stop_bits: StopBits) -> Result<()> {
        self.inner.set_stop_bits(stop_bits)
    }

    fn set_timeout(&mut self, _: Duration) -> Result<()> {
        Ok(())
    }

    fn write_request_to_send(&mut self, level: bool) -> Result<()> {
        self.inner.write_request_to_send(level)
    }

    fn write_data_terminal_ready(&mut self, level: bool) -> Result<()> {
        self.inner.write_data_terminal_ready(level)
    }

    fn read_clear_to_send(&mut self) -> Result<bool> {
        self.inner.read_clear_to_send()
    }

    fn read_data_set_ready(&mut self) -> Result<bool> {
        self.inner.read_data_set_ready()
    }

    fn read_ring_indicator(&mut self) -> Result<bool> {
        self.inner.read_ring_indicator()
    }

    fn read_carrier_detect(&mut self) -> Result<bool> {
        self.inner.read_carrier_detect()
    }

    fn bytes_to_read(&self) -> Result<u32> {
        self.inner.bytes_to_read()
    }

    fn bytes_to_write(&self) -> Result<u32> {
        self.inner.bytes_to_write()
    }

    fn clear(&self, buffer_to_clear: ClearBuffer) -> Result<()> {
        self.inner.clear(buffer_to_clear)
    }

    fn try_clone(&self) -> Result<Box<dyn SerialPort>> {
        self.inner.try_clone()
    }
}

impl Read for Serial {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.inner.read(buf)
    }
}

impl Write for Serial {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.inner.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

#[cfg(unix)]
use std::os::unix::io::{AsRawFd, RawFd};
#[cfg(unix)]
impl AsRawFd for Serial {
    fn as_raw_fd(&self) -> RawFd {
        self.io.get_ref().as_raw_fd()
    }
}

impl AsyncRead for Serial {
    fn poll_read(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut ReadBuf<'_>,
    ) -> Poll<io::Result<()>> {
        let this = self.get_mut();
        let inner = &mut this.inner;

        let io_pin = Pin::new(&mut this.io);

        // because we're edge-triggered, but we do this funky thing with the AsyncFdReadyGuard
        // there's a chance that we'll race the readiness guard and never get woken up again.
        //
        // particularly -- we'll get a readyguard because there's a readiness flag set (i.e., the OS has
        // notified tokio that /something/ happened on the FD -- but that doesn't necessarily mean that there's
        // any data to read. so we'll get our ReadyGuard because the read_readiness bit is set internally in tokio::io::driver,
        // but if it was some weird control char and not actual readable data, then our read would return EAGAIN/EWOULDBLOCK,
        // clearing the ready flag. Because we had the AsyndFdReadyGuard to begin with, it means our waker wasn't registered with
        // mio or whatever is doing the i/o driving.
        //
        // in 99% of use cases, that design is completely sensible -- usually things don't say theyre ready to be read
        // when they're not actually ready to be read. but serial ports are apparently weird because you could be read_ready without
        // anything to read, it seems ¯\_(ツ)_/¯
        //
        // meanwhile, anything reading higher up (particualrly, FramedRead), will assume that there's
        // nothing to do since there's nothing new in the buffer it's working against. and then just proceed to return None.
        // anything consuming that stream will just just sit in Pending, none-the-wiser, assuming that FramedRead,
        // registered the future to woken up. And FramedRead assumed that we as the underlying AsyncRead registered the supplied
        // context for a wake.
        //
        // This only took a week to figure out :)
        let mut total_read = 0usize;
        loop {
            let mut guard = match io_pin.poll_read_ready(cx) {
                Poll::Ready(Ok(x)) => x,
                Poll::Ready(Err(e)) => return Poll::Ready(Err(e)),
                Poll::Pending => {
                    if total_read == 0 {
                        return Poll::Pending;
                    } else {
                        return Poll::Ready(Ok(()));
                    }
                }
            };
            let res = guard.try_io(|_afd| {
                let read = inner.read(buf.initialize_unfilled())?;
                buf.advance(read);
                total_read += read;
                Ok(())
            });

            match res {
                Ok(Err(err)) => return Poll::Ready(Err(err)),
                _ => continue, // in all other cases, we need to keep looping to register the waker for more data...
            }
        }
    }
}

// Thankfully, writes don't appear to suffer from the nonsense mentioned above...
impl AsyncWrite for Serial {
    fn poll_write(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &[u8],
    ) -> Poll<io::Result<usize>> {
        let this = self.get_mut();
        let inner = &mut this.inner;
        let io_pin = Pin::new(&mut this.io);
        let mut guard = match io_pin.poll_write_ready(cx) {
            Poll::Ready(Ok(x)) => x,
            Poll::Ready(Err(e)) => return Poll::Ready(Err(e)),
            Poll::Pending => return Poll::Pending,
        };
        match guard.try_io(|_afd| inner.write(buf)) {
            Ok(x) => Poll::Ready(x),
            Err(TryIoError { .. }) => Poll::Pending,
        }
    }

    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {
        let this = self.get_mut();
        let inner = &mut this.inner;
        let io_pin = Pin::new(&mut this.io);
        let mut guard = match io_pin.poll_write_ready(cx) {
            Poll::Ready(Ok(x)) => x,
            Poll::Ready(Err(e)) => return Poll::Ready(Err(e)),
            Poll::Pending => return Poll::Pending,
        };
        let res = guard.try_io(|_afd| inner.flush());
        match res {
            Ok(x) => Poll::Ready(x),
            Err(TryIoError { .. }) => Poll::Pending,
        }
    }

    fn poll_shutdown(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<io::Result<()>> {
        Poll::Ready(Ok(()))
    }
}
